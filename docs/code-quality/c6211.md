---
title: C6211
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6211
helpviewer_keywords:
- C6211
ms.assetid: 9b68243b-534c-4a05-b789-bb155dfcba1e
ms.openlocfilehash: 8f9cb312c016622ecf3eac4e63140418543531c1
ms.sourcegitcommit: 7bea0420d0e476287641edeb33a9d5689a98cb98
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/17/2020
ms.locfileid: "79468796"
---
# <a name="c6211"></a>C6211

> ADVERTENCIA C6211: pérdida de memoria \<puntero > debido a una excepción. Considere la posibilidad de usar un bloque catch local para limpiar la memoria

Esta advertencia indica que no se libera memoria asignada cuando se produce una excepción. La instrucción al final de la ruta de acceso podría producir una excepción. El analizador comprueba esta condición solo cuando se especifica la anotación SAL `_Analysis_mode_(_Analysis_local_leak_checks_)`. De forma predeterminada, esta anotación se especifica para el código del modo kernel de Windows (controlador). Para obtener más información sobre las anotaciones SAL, consulte [uso de anotaciones sal para reducir defectosC++ de C/Code](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).

## <a name="example"></a>Ejemplo

El código siguiente genera esta advertencia porque se puede producir una excepción durante la segunda asignación y, por tanto, se pierde la primera asignación, o bien se puede iniciar una excepción en algún lugar del código representado por el comentario "`code ...`" y, por tanto, se pueden filtrar ambas asignaciones.

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>

_Analysis_mode_(_Analysis_local_leak_checks_)
void f( )
{
    char *p1 = new char[10];
    char *p2 = new char[10];

    // code ...

    delete[] p2;
    delete[] p1;
}
```

Para usar las mismas funciones de asignación y corregir este problema, agregue un controlador de excepciones:

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <new>
#include <iostream>
using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_)

void f()
{
    char *p1 = nullptr;
    char *p2 = nullptr;

    try
    {
        p1 = new char[10];
        p2 = new char[10];

        // code ...

        delete [] p2;
        delete [] p1;
    }
    catch (const bad_alloc& ba)
    {
        cout << ba.what() << endl;
        delete [] p2;
        delete [] p1;
    }
    // code ...
}
```

Para evitar todos estos tipos de fugas posibles, use los mecanismos proporcionados por la biblioteca de C++ plantillas estándar (STL). Entre ellas se incluyen [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)y [Vector](/cpp/standard-library/vector). Para obtener más información, vea [punteros inteligentes](/cpp/cpp/smart-pointers-modern-cpp) y [ C++ biblioteca estándar](/cpp/standard-library/cpp-standard-library-reference).

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <vector>
#include <memory>

using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_)

void f( )
{
    // use 10-element vectors in place of char[10]
    vector<char> v1;
    vector<char> v2;

    for (int i=0; i<10; ++i) {
        v1.push_back('a');
        v2.push_back('b');
    }
    // code ...

    // use unique_ptr if you still want char[10]
    unique_ptr<char[]> a1(new char[10]);
    unique_ptr<char[]> a2(new char[10]);

    // code ...

    // No need for delete; vector and unique_ptr
    // clean up when out of scope.
}
```

## <a name="see-also"></a>Consulte también

[Control de excepciones de C++](/cpp/cpp/cpp-exception-handling)
