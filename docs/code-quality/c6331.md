---
title: C6331
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6331
helpviewer_keywords:
- C6331
ms.assetid: cb1ecc2c-29a5-4c57-acf2-0954a4c047b1
ms.openlocfilehash: 03b6144b127640137216a64d1d477a27bd317157
ms.sourcegitcommit: 7bea0420d0e476287641edeb33a9d5689a98cb98
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/17/2020
ms.locfileid: "79467860"
---
# <a name="c6331"></a>C6331

> ADVERTENCIA C6331: parámetro no válido: no se permite pasar MEM_RELEASE y MEM_DECOMMIT en conjunción con \<función >. Esto provocará un error en la llamada

Este mensaje indica que se pasa un parámetro no válido a VirtualFree o VirtualFreeEx. VirtualFree y VirtualFreeEx rechazan las marcas (MEM_RELEASE &#124; MEM_DECOMMIT) en combinación. Por consiguiente, los valores MEM_DECOMMIT y MEM_RELEASE no se pueden utilizar juntos en la misma llamada.

No es imprescindible que la anulación de registro y la liberación se realicen en pasos independientes. Al liberar la memoria confirmada, también se anula el registro de las páginas. Además, asegúrese de que no se omita el valor devuelto de esta función.

## <a name="example"></a>Ejemplo

El siguiente ejemplo de código genera esta advertencia:

```cpp
#include <windows.h>
#define PAGELIMIT 80

DWORD dwPages = 0;  // count of pages
DWORD dwPageSize;   // page size

VOID fd( VOID )
{
  LPVOID lpvBase;            // base address of the test memory
  BOOL bSuccess;
  SYSTEM_INFO sSysInfo;      // system information

  GetSystemInfo( &sSysInfo );
  dwPageSize = sSysInfo.dwPageSize;

  // Reserve pages in the process's virtual address space
  lpvBase = VirtualAlloc (
                       NULL,                 // system selects address
                       PAGELIMIT*dwPageSize, // size of allocation
                       MEM_RESERVE,
                       PAGE_NOACCESS );
  if (lpvBase)
  {
    // code to access memory
  }
  else
  {
    return;
  }
  bSuccess = VirtualFree(lpvBase,
                0,
                MEM_DECOMMIT | MEM_RELEASE); // warning
  // code...
}
```

Para corregir esta advertencia, no pase el valor MEM_DECOMMIT a la llamada a VirtualFree como se muestra el código siguiente:

```cpp
#include <windows.h>
#define PAGELIMIT 80

DWORD dwPages = 0;  // count of pages
DWORD dwPageSize;   // page size

VOID f( VOID )
{
  LPVOID lpvBase;            // base address of the test memory
  BOOL bSuccess;
  SYSTEM_INFO sSysInfo;      // system information

  GetSystemInfo( &sSysInfo );
  dwPageSize = sSysInfo.dwPageSize;

  // Reserve pages in the process's virtual address space
  lpvBase = VirtualAlloc (
                       NULL,                 // system selects address
                       PAGELIMIT*dwPageSize, // size of allocation
                       MEM_RESERVE,
                       PAGE_NOACCESS );
  if (lpvBase)
  {
    // code to access memory
  }
  else
  {
    return;
  }
  bSuccess = VirtualFree(lpvBase, 0, MEM_RELEASE);
  // code...
}
```

Tenga en cuenta que el uso de las opciones malloc y free (y las API de asignación de memoria dinámica relacionadas) tiene muchos riesgos en cuanto a pérdidas de memoria y excepciones. Para evitar todos estos tipos de problemas de pérdidas de memoria y excepciones, use los mecanismos proporcionados por la Biblioteca de plantillas estándar (STL) de C++. Entre ellas se incluyen [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)y [Vector](/cpp/standard-library/vector). Para obtener más información, vea [punteros inteligentes](/cpp/cpp/smart-pointers-modern-cpp) y [ C++ biblioteca estándar](/cpp/standard-library/cpp-standard-library-reference).

## <a name="see-also"></a>Consulte también

- [VirtualAlloc (método)](/dotnet/framework/unmanaged-api/hosting/ihostmemorymanager-virtualalloc-method)
- [VirtualFree (método)](/dotnet/framework/unmanaged-api/hosting/ihostmemorymanager-virtualfree-method)
